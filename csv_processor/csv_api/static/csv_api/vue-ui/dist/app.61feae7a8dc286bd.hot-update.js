"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatevue_autocomplete_component_example"]("app",{

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=script&lang=js":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=script&lang=js ***!
  \****************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'SearchAutocomplete',\n  props: {\n    items: {\n      type: Array,\n      required: false,\n      default: () => []\n    }\n  },\n  data() {\n    /* Here we initialize all the variables */\n    return {\n      search: '',\n      // initialize search results\n      results: [],\n      // receive an array\n      isOpen: false,\n      // start with the component closed\n      /* index of the currently selected/highlighted item. When it is -1,\r\n      no item is selected.*/\n      selectedIndex: -1,\n      nextInputValue: ''\n    };\n  },\n  mounted() {\n    document.addEventListener('click', this.handleClickOutside);\n  },\n  beforeUnmount() {\n    document.removeEventListener('click', this.handleClickOutside);\n  },\n  methods: {\n    /* Helper to clear the search box */\n    clearTxt() {\n      this.search = '';\n    },\n    /* Helper to clear and close the search box */\n    resetCmp() {\n      this.search = '';\n      this.isOpen = false;\n    },\n    /* If you only work in English, just use this function indeed instead of fiterResults */\n    filterResultsUnaccented() {\n      this.results = this.items.filter(item => item.toLowerCase().indexOf(this.search.toLowerCase()) > -1);\n    },\n    /* Unicode version of filterResultsUnaccented. All the accented characters\r\n     such as à, á, â, ã, etc. will be treated like \"a\". Great for multilanguage\r\n      autocomplete. */\n    filterResults() {\n      const searchTerm = this.search.toLowerCase();\n      this.results = this.items.filter(item => {\n        /* The \\u0300-\\u036f Unicode range, primarily covers the diacritics used in the Latin script, which indeed includes a vast majority of European languages. The following normalizes the list of names. */\n        const normalizedItem = item.toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n        /* This normalizes the search term in the autocomplete input field */\n        const normalizedSearch = searchTerm.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n        // Check if the normalized item contains the normalized search term\n        return normalizedItem.indexOf(normalizedSearch) > -1;\n      });\n    },\n    /* The user typed a new letter in the input box (or deleted it) and the search\r\n    \tsuggestions should be adjusted accordingly. */\n    onChange() {\n      this.filterResults();\n      // Check for non-empty input or non-empty results\n      if (this.search.trim() !== '' || this.results.length > 0) {\n        this.isOpen = true;\n      } else {\n        this.selectedIndex = -1;\n        this.isOpen = false;\n      }\n    },\n    /* Called when the user clicks or taps outside the component. */\n    handleClickOutside(event) {\n      if (!this.$el.contains(event.target)) {\n        this.selectedIndex = -1;\n        this.isOpen = false;\n        /* Not good, because it would act even after a right choice. Clicking\r\n        outside the component should not delete anything. */\n        // this.clearTxt();\n      }\n    },\n    /* Keyboard support, fired when the use uses arrow keys to navigate \r\n    through the list. This one addresses the arrow down key. */\n    onArrowDown() {\n      this.clearHoverSelection();\n      if (this.selectedIndex < this.results.length - 1) {\n        this.selectedIndex++;\n        this.addHoverSelection();\n        this.calculateScrollPosition();\n      }\n    },\n    /* Addresses the arrow up key */\n    onArrowUp() {\n      if (this.selectedIndex > 0) {\n        this.selectedIndex--;\n        this.calculateScrollPosition();\n      }\n    },\n    /* When Enter is pressed the currently selected index gets choosed. */\n    onEnter() {\n      this.search = this.results[this.selectedIndex];\n      this.selectedIndex = -1;\n      this.isOpen = false;\n    },\n    /* Sets the search input to the value of the currently highlighted item, then close \r\n    the suggestions by setting isOpen to false.*/\n    selectItem() {\n      if (this.selectedIndex !== -1) {\n        this.search = this.results[this.selectedIndex];\n        this.isOpen = false;\n        // Focus on the next input element\n        this.$nextTick(() => {\n          const nextInput = this.$refs.nextInputElement;\n          if (nextInput && nextInput.focus) {\n            nextInput.focus();\n          }\n        });\n      }\n    },\n    /* This function and the next one seem to be necessary when the user begins to use\r\n    the keyboard after the user previously used the mouse. Not sure if these methods\r\n    are really needed. Comments are apprecied.*/\n    clearHoverSelection() {\n      this.$refs.resultsList.querySelectorAll('.autocomplete-result').forEach((element, index) => {\n        if (index !== this.selectedIndex) {\n          element.classList.remove('is-active');\n        }\n      });\n    },\n    addHoverSelection() {\n      this.$refs.resultsList.querySelectorAll('.autocomplete-result').forEach((element, index) => {\n        if (index === this.selectedIndex) {\n          element.classList.add('is-active');\n        }\n      });\n    },\n    /* Keeps the selection of the item always vertically centered. */\n    calculateScrollPosition() {\n      const computedStyle = window.getComputedStyle(this.$refs.resultsList);\n      const fontSize = parseFloat(computedStyle.fontSize);\n      // the following line was commented because it doesn't work\n      //const lineSpacing = parseFloat(computedStyle.lineHeight) || 1.5;\n      const lineSpacing = 1.5;\n      //console.log(computedStyle.lineHeight);\n      const container = this.$refs.resultsList;\n      const scrollPosition = (this.selectedIndex - 3) * lineSpacing * fontSize;\n      container.scrollTop = scrollPosition;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMF0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3NyYy9jb21wb25lbnRzL1NlYXJjaEF1dG9jb21wbGV0ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMiLCJtYXBwaW5ncyI6IjtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWF1dG9jb21wbGV0ZS1jb21wb25lbnQtZXhhbXBsZS8uL3NyYy9jb21wb25lbnRzL1NlYXJjaEF1dG9jb21wbGV0ZS52dWU/NDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcblx0PGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZVwiPlxyXG5cdFx0PCEtLSBJbiB0aGUgc2V0dXAgYmVsb3csIHRoZSBwcmV2ZW50IG1vZGlmaWVyIGVuc3VyZXMgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgYXJyb3cga2V5cyBpcyBwcmV2ZW50ZWQsIGFsbG93aW5nIHlvdXIgY3VzdG9tIGtleSBldmVudCBoYW5kbGluZyB0byB0YWtlIGVmZmVjdC4gLS0+XHJcblx0XHQ8aW5wdXQgdi1tb2RlbD1cInNlYXJjaFwiIFxyXG5cdFx0XHRAaW5wdXQ9XCJvbkNoYW5nZVwiIFxyXG5cdFx0XHRAZm9jdXM9XCJjbGVhclR4dFwiXHJcblx0XHRcdEBrZXlkb3duLmVzYy5wcmV2ZW50PVwicmVzZXRDbXBcIlxyXG5cdFx0XHRAa2V5ZG93bi5kb3duLnByZXZlbnQ9XCJvbkFycm93RG93blwiIFxyXG5cdFx0XHRAa2V5ZG93bi51cC5wcmV2ZW50PVwib25BcnJvd1VwXCJcclxuXHRcdFx0QGtleWRvd24uZW50ZXIucHJldmVudD1cInNlbGVjdEl0ZW1cIiBcclxuXHRcdFx0QGtleWRvd24udGFiLnByZXZlbnQ9XCJzZWxlY3RJdGVtXCIgXHJcblx0XHRcdHR5cGU9XCJ0ZXh0XCJcclxuXHRcdFx0cmVmPVwiaW5wdXRGaWVsZFwiXHJcblx0XHQvPlxyXG5cdFx0PCEtLSBUaGUgbW91c2VvdmVyIGV2ZW50IGhlcmUgaXMgdmVyeSBpbXBvcnRhbnQsIGJlY2F1c2UgaXQgYWxsb3dzXHJcblx0XHR0byBzZWxlY3QgdGhlIGVsZW1lbnQgb24gcHJlc3NpbmcgZW50ZXIgb3IgdGFiLCBldmVuIGlmIHRoaXMgdGFrZXNcclxuXHRcdG1vcmUgdGhhbiB0aGF0IC0tPlxyXG5cdFx0PHVsIHYtc2hvdz1cImlzT3BlblwiIFxyXG5cdFx0XHRjbGFzcz1cImF1dG9jb21wbGV0ZS1yZXN1bHRzXCIgXHJcblx0XHRcdHJlZj1cInJlc3VsdHNMaXN0XCJcclxuXHRcdD5cclxuXHRcdFx0PCEtLSBUaGUgcmVzdWx0IHZhcmlhYmxlIGlzIG9ubHkgdXNlZCB0byBjeWNsZSB0aHJvdWdoIHRoZSBmZXRlY2hlZFxyXG5cdFx0XHRyZXN1bHQgYW5kIHRvIHBvcHVsYXRlIHRoZSBkb20gbGlzdC4gcmVzdWx0IGlzIG5vdCBuZWVkZWQgdG8gYWN0dWFsbHlcclxuXHRcdFx0c2VsZWN0IGFuIGVsZW1lbnQgYmVjYXVzZSBpdHMgaW5kZXggaXMgdXNlZCBpbnN0ZWFkIC0tPlxyXG5cdFx0XHQ8bGkgdi1mb3I9XCIocmVzdWx0LCBpKSBpbiByZXN1bHRzXCIgXHJcblx0XHRcdFx0OmtleT1cImlcIiBcclxuXHRcdFx0XHRAY2xpY2s9XCJzZWxlY3RJdGVtKClcIiBcclxuXHRcdFx0XHRAbW91c2VvdmVyPVwic2VsZWN0ZWRJbmRleCA9IGlcIlxyXG5cdFx0XHRcdGNsYXNzPVwiYXV0b2NvbXBsZXRlLXJlc3VsdFwiIFxyXG5cdFx0XHRcdDpjbGFzcz1cInsgJ2lzLWFjdGl2ZSc6IGkgPT09IHNlbGVjdGVkSW5kZXggfVwiPlxyXG5cdFx0XHRcdHt7IHJlc3VsdCB9fVxyXG5cdFx0XHQ8L2xpPlxyXG5cdFx0PC91bD5cclxuXHQ8L2Rpdj5cclxuXHQ8ZGl2PlxyXG5cdFx0PGlucHV0IGNsYXNzPVwibmV4dEVsZVwiIHYtbW9kZWw9XCJuZXh0SW5wdXRWYWx1ZVwiIHJlZj1cIm5leHRJbnB1dEVsZW1lbnRcIiB0eXBlPVwidGV4dFwiXHJcblx0XHRcdHBsYWNlaG9sZGVyPVwiaWxsdXN0cmF0aW5nIHRoZSBmb2N1c1wiIC8+XHJcblx0PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRuYW1lOiAnU2VhcmNoQXV0b2NvbXBsZXRlJyxcclxuXHRwcm9wczoge1xyXG5cdFx0aXRlbXM6IHtcclxuXHRcdFx0dHlwZTogQXJyYXksXHJcblx0XHRcdHJlcXVpcmVkOiBmYWxzZSxcclxuXHRcdFx0ZGVmYXVsdDogKCkgPT4gW10sXHJcblx0XHR9LFxyXG5cdH0sXHJcblx0ZGF0YSgpIHtcclxuXHRcdC8qIEhlcmUgd2UgaW5pdGlhbGl6ZSBhbGwgdGhlIHZhcmlhYmxlcyAqL1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c2VhcmNoOiAnJyxcdFx0Ly8gaW5pdGlhbGl6ZSBzZWFyY2ggcmVzdWx0c1xyXG5cdFx0XHRyZXN1bHRzOiBbXSxcdC8vIHJlY2VpdmUgYW4gYXJyYXlcclxuXHRcdFx0aXNPcGVuOiBmYWxzZSxcdC8vIHN0YXJ0IHdpdGggdGhlIGNvbXBvbmVudCBjbG9zZWRcclxuXHRcdFx0LyogaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZC9oaWdobGlnaHRlZCBpdGVtLiBXaGVuIGl0IGlzIC0xLFxyXG5cdFx0XHRubyBpdGVtIGlzIHNlbGVjdGVkLiovXHJcblx0XHRcdHNlbGVjdGVkSW5kZXg6IC0xLCBcclxuXHRcdFx0bmV4dElucHV0VmFsdWU6ICcnLFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cdG1vdW50ZWQoKSB7XHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuXHR9LFxyXG5cdGJlZm9yZVVubW91bnQoKSB7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuXHR9LFxyXG5cdG1ldGhvZHM6IHtcclxuXHRcdC8qIEhlbHBlciB0byBjbGVhciB0aGUgc2VhcmNoIGJveCAqL1xyXG5cdFx0Y2xlYXJUeHQoKXtcclxuXHRcdFx0dGhpcy5zZWFyY2g9Jyc7XHJcblx0XHR9LFxyXG5cdFx0LyogSGVscGVyIHRvIGNsZWFyIGFuZCBjbG9zZSB0aGUgc2VhcmNoIGJveCAqL1xyXG5cdFx0cmVzZXRDbXAoKXtcclxuXHRcdFx0dGhpcy5zZWFyY2g9Jyc7XHJcblx0XHRcdHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvKiBJZiB5b3Ugb25seSB3b3JrIGluIEVuZ2xpc2gsIGp1c3QgdXNlIHRoaXMgZnVuY3Rpb24gaW5kZWVkIGluc3RlYWQgb2YgZml0ZXJSZXN1bHRzICovXHJcblx0XHRmaWx0ZXJSZXN1bHRzVW5hY2NlbnRlZCgpIHtcclxuXHRcdFx0dGhpcy5yZXN1bHRzID0gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnNlYXJjaC50b0xvd2VyQ2FzZSgpKSA+IC0xKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyogVW5pY29kZSB2ZXJzaW9uIG9mIGZpbHRlclJlc3VsdHNVbmFjY2VudGVkLiBBbGwgdGhlIGFjY2VudGVkIGNoYXJhY3RlcnNcclxuXHRcdCBzdWNoIGFzIMOgLCDDoSwgw6IsIMOjLCBldGMuIHdpbGwgYmUgdHJlYXRlZCBsaWtlIFwiYVwiLiBHcmVhdCBmb3IgbXVsdGlsYW5ndWFnZVxyXG5cdFx0ICBhdXRvY29tcGxldGUuICovXHJcblx0XHRmaWx0ZXJSZXN1bHRzKCl7XHJcblx0XHRcdGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHR0aGlzLnJlc3VsdHMgPSB0aGlzLml0ZW1zLmZpbHRlcihpdGVtID0+IHtcclxuXHRcdFx0XHQvKiBUaGUgXFx1MDMwMC1cXHUwMzZmIFVuaWNvZGUgcmFuZ2UsIHByaW1hcmlseSBjb3ZlcnMgdGhlIGRpYWNyaXRpY3MgdXNlZCBpbiB0aGUgTGF0aW4gc2NyaXB0LCB3aGljaCBpbmRlZWQgaW5jbHVkZXMgYSB2YXN0IG1ham9yaXR5IG9mIEV1cm9wZWFuIGxhbmd1YWdlcy4gVGhlIGZvbGxvd2luZyBub3JtYWxpemVzIHRoZSBsaXN0IG9mIG5hbWVzLiAqL1xyXG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRJdGVtID0gaXRlbS50b0xvd2VyQ2FzZSgpLm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKTtcclxuXHRcdFx0XHQvKiBUaGlzIG5vcm1hbGl6ZXMgdGhlIHNlYXJjaCB0ZXJtIGluIHRoZSBhdXRvY29tcGxldGUgaW5wdXQgZmllbGQgKi9cclxuXHRcdFx0XHRjb25zdCBub3JtYWxpemVkU2VhcmNoID0gc2VhcmNoVGVybS5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIik7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG5vcm1hbGl6ZWQgaXRlbSBjb250YWlucyB0aGUgbm9ybWFsaXplZCBzZWFyY2ggdGVybVxyXG5cdFx0XHRcdHJldHVybiBub3JtYWxpemVkSXRlbS5pbmRleE9mKG5vcm1hbGl6ZWRTZWFyY2gpID4gLTE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdC8qIFRoZSB1c2VyIHR5cGVkIGEgbmV3IGxldHRlciBpbiB0aGUgaW5wdXQgYm94IChvciBkZWxldGVkIGl0KSBhbmQgdGhlIHNlYXJjaFxyXG5cdFx0XHRzdWdnZXN0aW9ucyBzaG91bGQgYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkuICovXHJcblx0XHRvbkNoYW5nZSgpIHtcclxuXHRcdFx0dGhpcy5maWx0ZXJSZXN1bHRzKCk7XHJcblx0XHRcdC8vIENoZWNrIGZvciBub24tZW1wdHkgaW5wdXQgb3Igbm9uLWVtcHR5IHJlc3VsdHNcclxuXHRcdFx0aWYgKHRoaXMuc2VhcmNoLnRyaW0oKSAhPT0gJycgfHwgdGhpcy5yZXN1bHRzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR0aGlzLmlzT3BlbiA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcblx0XHRcdFx0dGhpcy5pc09wZW4gPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIENhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvciB0YXBzIG91dHNpZGUgdGhlIGNvbXBvbmVudC4gKi9cclxuXHRcdGhhbmRsZUNsaWNrT3V0c2lkZShldmVudCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuJGVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcclxuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuXHRcdFx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG5cdFx0XHRcdC8qIE5vdCBnb29kLCBiZWNhdXNlIGl0IHdvdWxkIGFjdCBldmVuIGFmdGVyIGEgcmlnaHQgY2hvaWNlLiBDbGlja2luZ1xyXG5cdFx0XHRcdG91dHNpZGUgdGhlIGNvbXBvbmVudCBzaG91bGQgbm90IGRlbGV0ZSBhbnl0aGluZy4gKi9cclxuXHRcdFx0XHQvLyB0aGlzLmNsZWFyVHh0KCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKiBLZXlib2FyZCBzdXBwb3J0LCBmaXJlZCB3aGVuIHRoZSB1c2UgdXNlcyBhcnJvdyBrZXlzIHRvIG5hdmlnYXRlIFxyXG5cdFx0dGhyb3VnaCB0aGUgbGlzdC4gVGhpcyBvbmUgYWRkcmVzc2VzIHRoZSBhcnJvdyBkb3duIGtleS4gKi9cclxuXHRcdG9uQXJyb3dEb3duKCkge1xyXG5cdFx0XHR0aGlzLmNsZWFySG92ZXJTZWxlY3Rpb24oKTtcclxuXHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEluZGV4Kys7XHJcblx0XHRcdFx0dGhpcy5hZGRIb3ZlclNlbGVjdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMuY2FsY3VsYXRlU2Nyb2xsUG9zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHQvKiBBZGRyZXNzZXMgdGhlIGFycm93IHVwIGtleSAqL1xyXG5cdFx0b25BcnJvd1VwKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3RlZEluZGV4ID4gMCkge1xyXG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJbmRleC0tO1xyXG5cdFx0XHRcdHRoaXMuY2FsY3VsYXRlU2Nyb2xsUG9zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIFdoZW4gRW50ZXIgaXMgcHJlc3NlZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGdldHMgY2hvb3NlZC4gKi9cclxuXHRcdG9uRW50ZXIoKSB7XHJcblx0XHRcdHRoaXMuc2VhcmNoID0gdGhpcy5yZXN1bHRzW3RoaXMuc2VsZWN0ZWRJbmRleF07XHJcblx0XHRcdHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG5cdFx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdC8qIFNldHMgdGhlIHNlYXJjaCBpbnB1dCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnRseSBoaWdobGlnaHRlZCBpdGVtLCB0aGVuIGNsb3NlIFxyXG5cdFx0dGhlIHN1Z2dlc3Rpb25zIGJ5IHNldHRpbmcgaXNPcGVuIHRvIGZhbHNlLiovXHJcblx0XHRzZWxlY3RJdGVtKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHRoaXMuc2VhcmNoID0gdGhpcy5yZXN1bHRzW3RoaXMuc2VsZWN0ZWRJbmRleF07XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcblx0XHRcdFx0Ly8gRm9jdXMgb24gdGhlIG5leHQgaW5wdXQgZWxlbWVudFxyXG5cdFx0XHRcdHRoaXMuJG5leHRUaWNrKCgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5leHRJbnB1dCA9IHRoaXMuJHJlZnMubmV4dElucHV0RWxlbWVudDtcclxuXHRcdFx0XHRcdGlmKG5leHRJbnB1dCAmJiBuZXh0SW5wdXQuZm9jdXMpe1xyXG5cdFx0XHRcdFx0XHRuZXh0SW5wdXQuZm9jdXMoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIFRoaXMgZnVuY3Rpb24gYW5kIHRoZSBuZXh0IG9uZSBzZWVtIHRvIGJlIG5lY2Vzc2FyeSB3aGVuIHRoZSB1c2VyIGJlZ2lucyB0byB1c2VcclxuXHRcdHRoZSBrZXlib2FyZCBhZnRlciB0aGUgdXNlciBwcmV2aW91c2x5IHVzZWQgdGhlIG1vdXNlLiBOb3Qgc3VyZSBpZiB0aGVzZSBtZXRob2RzXHJcblx0XHRhcmUgcmVhbGx5IG5lZWRlZC4gQ29tbWVudHMgYXJlIGFwcHJlY2llZC4qL1xyXG5cdFx0Y2xlYXJIb3ZlclNlbGVjdGlvbigpIHtcclxuXHRcdFx0dGhpcy4kcmVmcy5yZXN1bHRzTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCcuYXV0b2NvbXBsZXRlLXJlc3VsdCcpLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0aWYgKGluZGV4ICE9PSB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcclxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkSG92ZXJTZWxlY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuJHJlZnMucmVzdWx0c0xpc3QucXVlcnlTZWxlY3RvckFsbCgnLmF1dG9jb21wbGV0ZS1yZXN1bHQnKS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4KSB7XHJcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qIEtlZXBzIHRoZSBzZWxlY3Rpb24gb2YgdGhlIGl0ZW0gYWx3YXlzIHZlcnRpY2FsbHkgY2VudGVyZWQuICovXHJcblx0XHRjYWxjdWxhdGVTY3JvbGxQb3NpdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMucmVzdWx0c0xpc3QpO1xyXG5cdFx0XHRjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5mb250U2l6ZSk7XHJcblx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgbGluZSB3YXMgY29tbWVudGVkIGJlY2F1c2UgaXQgZG9lc24ndCB3b3JrXHJcblx0XHRcdC8vY29uc3QgbGluZVNwYWNpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUubGluZUhlaWdodCkgfHwgMS41O1xyXG5cdFx0XHRjb25zdCBsaW5lU3BhY2luZyA9IDEuNTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhjb21wdXRlZFN0eWxlLmxpbmVIZWlnaHQpO1xyXG5cdFx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLiRyZWZzLnJlc3VsdHNMaXN0O1xyXG5cdFx0XHRjb25zdCBzY3JvbGxQb3NpdGlvbiA9ICh0aGlzLnNlbGVjdGVkSW5kZXggLSAzKSAqIGxpbmVTcGFjaW5nICogZm9udFNpemU7XHJcblx0XHRcdGNvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbjtcclxuXHRcdH0sXHJcblx0XHRcclxuXHR9LFxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4uYXV0b2NvbXBsZXRlIHtcclxuXHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG59XHJcblxyXG4vKiBUaGlzIHN0eWxlIGFwcGxpZXMgdG8gdGhlIGVudGlyZSBsaXN0ICovXHJcbi5hdXRvY29tcGxldGUtcmVzdWx0cy1vbGQge1xyXG5cdGxpc3Qtc3R5bGU6IG5vbmU7XHJcblx0dGV4dC1hbGlnbjogbGVmdDtcclxuXHRwYWRkaW5nOiAwO1xyXG5cdHdpZHRoOiAzMDBweDtcclxuXHRtYXgtaGVpZ2h0OiAyMDBweDtcclxuXHRvdmVyZmxvdy15OiBzY3JvbGw7XHJcblx0LyogT24gb3ZlcmZsb3csIHdpbGwgYWRkIGEgdmVydGljYWwgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgKi9cclxuXHRvdmVyZmxvdy14OiBhdXRvO1xyXG5cdC8qIE9uIG92ZXJmbG93LCB3aWxsIGFkZCBhIGhvcml6b250YWwgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgKi9cclxuXHRib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xyXG5cdC8qIEEgbmljZSBib3JkZXIgYXJvdW5kIHRoZSBzdWdnZXN0aW9uIGxpc3QgKi9cclxuXHRtYXJnaW46IDA7XHJcblx0Ym9yZGVyLXJhZGl1czogNXB4O1xyXG59XHJcblxyXG4vKiBUaGUgbmV3IHZlcnNpb24gaXMgbW9yZSBzdWl0YWJsZSBmb3IgNy13b3JkcyB2ZXJ0aWNhbCBhbGlnbm1lbnQgKi9cclxuLmF1dG9jb21wbGV0ZS1yZXN1bHRzIHtcclxuICBsaXN0LXN0eWxlOiBub25lO1xyXG4gIHRleHQtYWxpZ246IGxlZnQ7XHJcbiAgcGFkZGluZzogMDtcclxuICB3aWR0aDogMTAwJTsgLyogVXNlIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBjb250YWluZXIgKi9cclxuICBtYXgtaGVpZ2h0OiAxMC41cmVtOyAvKiBTZXQgbWF4IGhlaWdodCB0byBhY2NvbW1vZGF0ZSA3IGl0ZW1zICovXHJcbiAgbGluZS1oZWlnaHQ6MS41cmVtO1xyXG4gIG92ZXJmbG93LXk6IGF1dG87XHJcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcclxuICBtYXJnaW46IDA7XHJcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gIGRpc3BsYXk6IGJsb2NrO1xyXG4gIGZvbnQtc2l6ZToxcmVtO1xyXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xyXG59XHJcblxyXG4vKiBUaGlzIHN0eWxlIGFwcGxpZXMgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0ICovXHJcbi5hdXRvY29tcGxldGUtcmVzdWx0IHtcclxuXHQvKnBhZGRpbmc6IDRweCAycHg7Ki9cclxuXHQvKmZvbnQtZmFtaWx5OlZlcmRhbmEsIHNhbnMtc2VyaWY7Ki9cclxuXHRwYWRkaW5nOiAuNXJlbSwwO1xyXG5cdGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuLyogV2hlbiB0aGUgbW91c2UgaG92ZXJzIGFuZCBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBsaXN0LCBlYWNoIGl0ZW0gd2lsbCBiZSBoaWdobGlnaHRlZFxyXG5cdHdpdGggYSBuaWNlIGdyZWVuIGNvbG9yLiovXHJcbi5pcy1hY3RpdmV7XHJcblx0YmFja2dyb3VuZC1jb2xvcjogIzRBQUU5ODtcclxuXHRjb2xvcjogd2hpdGU7XHJcblx0d2lkdGg6MTAwJTtcclxufVxyXG5cclxuXHJcbi5uZXh0ZWxlIHtcclxuXHR3aWR0aDogYXV0bztcclxuXHRtYXJnaW4tdG9wOi4ycmVtO1xyXG5cdHBhZGRpbmc6IDA7XHJcblx0Ym94LXNpemluZzogY29udGVudC1ib3g7XHJcblx0LyogVG8gcHJldmVudCB0aGUgaW5wdXQgZnJvbSBncm93aW5nIHdoZW4gcGFkZGluZyBpcyBhZGRlZCAqL1xyXG59XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/webpack-plugin-vuetify/dist/scriptLoader.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=template&id=529fd040":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/webpack-plugin-vuetify/dist/scriptLoader.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=template&id=529fd040 ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: function() { return /* binding */ render; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n\nconst _hoisted_1 = {\n  class: \"autocomplete\"\n};\nconst _hoisted_2 = {\n  class: \"autocomplete-results\",\n  ref: \"resultsList\"\n};\nconst _hoisted_3 = [\"onMouseover\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\" In the setup below, the prevent modifier ensures that the default behavior of the arrow keys is prevented, allowing your custom key event handling to take effect. \"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => $data.search = $event),\n    onInput: _cache[1] || (_cache[1] = (...args) => $options.onChange && $options.onChange(...args)),\n    onFocus: _cache[2] || (_cache[2] = (...args) => $options.clearTxt && $options.clearTxt(...args)),\n    onKeydown: [_cache[3] || (_cache[3] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((...args) => $options.resetCmp && $options.resetCmp(...args), [\"prevent\"]), [\"esc\"])), _cache[4] || (_cache[4] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((...args) => $options.onArrowDown && $options.onArrowDown(...args), [\"prevent\"]), [\"down\"])), _cache[5] || (_cache[5] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((...args) => $options.onArrowUp && $options.onArrowUp(...args), [\"prevent\"]), [\"up\"])), _cache[6] || (_cache[6] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((...args) => $options.selectItem && $options.selectItem(...args), [\"prevent\"]), [\"enter\"])), _cache[7] || (_cache[7] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((...args) => $options.selectItem && $options.selectItem(...args), [\"prevent\"]), [\"tab\"]))],\n    type: \"text\",\n    ref: \"inputField\"\n  }, null, 544 /* NEED_HYDRATION, NEED_PATCH */), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.search]]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\" The mouseover event here is very important, because it allows\\r\\n\\t\\tto select the element on pressing enter or tab, even if this takes\\r\\n\\t\\tmore than that \"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"ul\", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\" The result variable is only used to cycle through the feteched\\r\\n\\t\\t\\tresult and to populate the dom list. result is not needed to actually\\r\\n\\t\\t\\tselect an element because its index is used instead \"), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($data.results, (result, i) => {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"li\", {\n      key: i,\n      onClick: _cache[8] || (_cache[8] = $event => $options.selectItem()),\n      onMouseover: $event => $data.selectedIndex = i,\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"autocomplete-result\", {\n        'is-active': i === $data.selectedIndex\n      }])\n    }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(result), 43 /* TEXT, CLASS, PROPS, NEED_HYDRATION */, _hoisted_3);\n  }), 128 /* KEYED_FRAGMENT */))], 512 /* NEED_PATCH */), [[vue__WEBPACK_IMPORTED_MODULE_0__.vShow, $data.isOpen]])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    class: \"nextEle\",\n    \"onUpdate:modelValue\": _cache[9] || (_cache[9] = $event => $data.nextInputValue = $event),\n    ref: \"nextInputElement\",\n    type: \"text\",\n    placeholder: \"illustrating the focus\"\n  }, null, 512 /* NEED_PATCH */), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.nextInputValue]])])], 64 /* STABLE_FRAGMENT */);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1wbHVnaW4tdnVldGlmeS9kaXN0L3NjcmlwdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbNF0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3NyYy9jb21wb25lbnRzL1NlYXJjaEF1dG9jb21wbGV0ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTI5ZmQwNDAiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBO0FBQUE7O0FBaUJBO0FBQ0E7Ozs7QUFsQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFUQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBYkE7QUFrQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWF1dG9jb21wbGV0ZS1jb21wb25lbnQtZXhhbXBsZS8uL3NyYy9jb21wb25lbnRzL1NlYXJjaEF1dG9jb21wbGV0ZS52dWU/NDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcblx0PGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZVwiPlxyXG5cdFx0PCEtLSBJbiB0aGUgc2V0dXAgYmVsb3csIHRoZSBwcmV2ZW50IG1vZGlmaWVyIGVuc3VyZXMgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgYXJyb3cga2V5cyBpcyBwcmV2ZW50ZWQsIGFsbG93aW5nIHlvdXIgY3VzdG9tIGtleSBldmVudCBoYW5kbGluZyB0byB0YWtlIGVmZmVjdC4gLS0+XHJcblx0XHQ8aW5wdXQgdi1tb2RlbD1cInNlYXJjaFwiIFxyXG5cdFx0XHRAaW5wdXQ9XCJvbkNoYW5nZVwiIFxyXG5cdFx0XHRAZm9jdXM9XCJjbGVhclR4dFwiXHJcblx0XHRcdEBrZXlkb3duLmVzYy5wcmV2ZW50PVwicmVzZXRDbXBcIlxyXG5cdFx0XHRAa2V5ZG93bi5kb3duLnByZXZlbnQ9XCJvbkFycm93RG93blwiIFxyXG5cdFx0XHRAa2V5ZG93bi51cC5wcmV2ZW50PVwib25BcnJvd1VwXCJcclxuXHRcdFx0QGtleWRvd24uZW50ZXIucHJldmVudD1cInNlbGVjdEl0ZW1cIiBcclxuXHRcdFx0QGtleWRvd24udGFiLnByZXZlbnQ9XCJzZWxlY3RJdGVtXCIgXHJcblx0XHRcdHR5cGU9XCJ0ZXh0XCJcclxuXHRcdFx0cmVmPVwiaW5wdXRGaWVsZFwiXHJcblx0XHQvPlxyXG5cdFx0PCEtLSBUaGUgbW91c2VvdmVyIGV2ZW50IGhlcmUgaXMgdmVyeSBpbXBvcnRhbnQsIGJlY2F1c2UgaXQgYWxsb3dzXHJcblx0XHR0byBzZWxlY3QgdGhlIGVsZW1lbnQgb24gcHJlc3NpbmcgZW50ZXIgb3IgdGFiLCBldmVuIGlmIHRoaXMgdGFrZXNcclxuXHRcdG1vcmUgdGhhbiB0aGF0IC0tPlxyXG5cdFx0PHVsIHYtc2hvdz1cImlzT3BlblwiIFxyXG5cdFx0XHRjbGFzcz1cImF1dG9jb21wbGV0ZS1yZXN1bHRzXCIgXHJcblx0XHRcdHJlZj1cInJlc3VsdHNMaXN0XCJcclxuXHRcdD5cclxuXHRcdFx0PCEtLSBUaGUgcmVzdWx0IHZhcmlhYmxlIGlzIG9ubHkgdXNlZCB0byBjeWNsZSB0aHJvdWdoIHRoZSBmZXRlY2hlZFxyXG5cdFx0XHRyZXN1bHQgYW5kIHRvIHBvcHVsYXRlIHRoZSBkb20gbGlzdC4gcmVzdWx0IGlzIG5vdCBuZWVkZWQgdG8gYWN0dWFsbHlcclxuXHRcdFx0c2VsZWN0IGFuIGVsZW1lbnQgYmVjYXVzZSBpdHMgaW5kZXggaXMgdXNlZCBpbnN0ZWFkIC0tPlxyXG5cdFx0XHQ8bGkgdi1mb3I9XCIocmVzdWx0LCBpKSBpbiByZXN1bHRzXCIgXHJcblx0XHRcdFx0OmtleT1cImlcIiBcclxuXHRcdFx0XHRAY2xpY2s9XCJzZWxlY3RJdGVtKClcIiBcclxuXHRcdFx0XHRAbW91c2VvdmVyPVwic2VsZWN0ZWRJbmRleCA9IGlcIlxyXG5cdFx0XHRcdGNsYXNzPVwiYXV0b2NvbXBsZXRlLXJlc3VsdFwiIFxyXG5cdFx0XHRcdDpjbGFzcz1cInsgJ2lzLWFjdGl2ZSc6IGkgPT09IHNlbGVjdGVkSW5kZXggfVwiPlxyXG5cdFx0XHRcdHt7IHJlc3VsdCB9fVxyXG5cdFx0XHQ8L2xpPlxyXG5cdFx0PC91bD5cclxuXHQ8L2Rpdj5cclxuXHQ8ZGl2PlxyXG5cdFx0PGlucHV0IGNsYXNzPVwibmV4dEVsZVwiIHYtbW9kZWw9XCJuZXh0SW5wdXRWYWx1ZVwiIHJlZj1cIm5leHRJbnB1dEVsZW1lbnRcIiB0eXBlPVwidGV4dFwiXHJcblx0XHRcdHBsYWNlaG9sZGVyPVwiaWxsdXN0cmF0aW5nIHRoZSBmb2N1c1wiIC8+XHJcblx0PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRuYW1lOiAnU2VhcmNoQXV0b2NvbXBsZXRlJyxcclxuXHRwcm9wczoge1xyXG5cdFx0aXRlbXM6IHtcclxuXHRcdFx0dHlwZTogQXJyYXksXHJcblx0XHRcdHJlcXVpcmVkOiBmYWxzZSxcclxuXHRcdFx0ZGVmYXVsdDogKCkgPT4gW10sXHJcblx0XHR9LFxyXG5cdH0sXHJcblx0ZGF0YSgpIHtcclxuXHRcdC8qIEhlcmUgd2UgaW5pdGlhbGl6ZSBhbGwgdGhlIHZhcmlhYmxlcyAqL1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c2VhcmNoOiAnJyxcdFx0Ly8gaW5pdGlhbGl6ZSBzZWFyY2ggcmVzdWx0c1xyXG5cdFx0XHRyZXN1bHRzOiBbXSxcdC8vIHJlY2VpdmUgYW4gYXJyYXlcclxuXHRcdFx0aXNPcGVuOiBmYWxzZSxcdC8vIHN0YXJ0IHdpdGggdGhlIGNvbXBvbmVudCBjbG9zZWRcclxuXHRcdFx0LyogaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZC9oaWdobGlnaHRlZCBpdGVtLiBXaGVuIGl0IGlzIC0xLFxyXG5cdFx0XHRubyBpdGVtIGlzIHNlbGVjdGVkLiovXHJcblx0XHRcdHNlbGVjdGVkSW5kZXg6IC0xLCBcclxuXHRcdFx0bmV4dElucHV0VmFsdWU6ICcnLFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cdG1vdW50ZWQoKSB7XHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuXHR9LFxyXG5cdGJlZm9yZVVubW91bnQoKSB7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuXHR9LFxyXG5cdG1ldGhvZHM6IHtcclxuXHRcdC8qIEhlbHBlciB0byBjbGVhciB0aGUgc2VhcmNoIGJveCAqL1xyXG5cdFx0Y2xlYXJUeHQoKXtcclxuXHRcdFx0dGhpcy5zZWFyY2g9Jyc7XHJcblx0XHR9LFxyXG5cdFx0LyogSGVscGVyIHRvIGNsZWFyIGFuZCBjbG9zZSB0aGUgc2VhcmNoIGJveCAqL1xyXG5cdFx0cmVzZXRDbXAoKXtcclxuXHRcdFx0dGhpcy5zZWFyY2g9Jyc7XHJcblx0XHRcdHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvKiBJZiB5b3Ugb25seSB3b3JrIGluIEVuZ2xpc2gsIGp1c3QgdXNlIHRoaXMgZnVuY3Rpb24gaW5kZWVkIGluc3RlYWQgb2YgZml0ZXJSZXN1bHRzICovXHJcblx0XHRmaWx0ZXJSZXN1bHRzVW5hY2NlbnRlZCgpIHtcclxuXHRcdFx0dGhpcy5yZXN1bHRzID0gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnNlYXJjaC50b0xvd2VyQ2FzZSgpKSA+IC0xKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyogVW5pY29kZSB2ZXJzaW9uIG9mIGZpbHRlclJlc3VsdHNVbmFjY2VudGVkLiBBbGwgdGhlIGFjY2VudGVkIGNoYXJhY3RlcnNcclxuXHRcdCBzdWNoIGFzIMOgLCDDoSwgw6IsIMOjLCBldGMuIHdpbGwgYmUgdHJlYXRlZCBsaWtlIFwiYVwiLiBHcmVhdCBmb3IgbXVsdGlsYW5ndWFnZVxyXG5cdFx0ICBhdXRvY29tcGxldGUuICovXHJcblx0XHRmaWx0ZXJSZXN1bHRzKCl7XHJcblx0XHRcdGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHR0aGlzLnJlc3VsdHMgPSB0aGlzLml0ZW1zLmZpbHRlcihpdGVtID0+IHtcclxuXHRcdFx0XHQvKiBUaGUgXFx1MDMwMC1cXHUwMzZmIFVuaWNvZGUgcmFuZ2UsIHByaW1hcmlseSBjb3ZlcnMgdGhlIGRpYWNyaXRpY3MgdXNlZCBpbiB0aGUgTGF0aW4gc2NyaXB0LCB3aGljaCBpbmRlZWQgaW5jbHVkZXMgYSB2YXN0IG1ham9yaXR5IG9mIEV1cm9wZWFuIGxhbmd1YWdlcy4gVGhlIGZvbGxvd2luZyBub3JtYWxpemVzIHRoZSBsaXN0IG9mIG5hbWVzLiAqL1xyXG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRJdGVtID0gaXRlbS50b0xvd2VyQ2FzZSgpLm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKTtcclxuXHRcdFx0XHQvKiBUaGlzIG5vcm1hbGl6ZXMgdGhlIHNlYXJjaCB0ZXJtIGluIHRoZSBhdXRvY29tcGxldGUgaW5wdXQgZmllbGQgKi9cclxuXHRcdFx0XHRjb25zdCBub3JtYWxpemVkU2VhcmNoID0gc2VhcmNoVGVybS5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIik7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG5vcm1hbGl6ZWQgaXRlbSBjb250YWlucyB0aGUgbm9ybWFsaXplZCBzZWFyY2ggdGVybVxyXG5cdFx0XHRcdHJldHVybiBub3JtYWxpemVkSXRlbS5pbmRleE9mKG5vcm1hbGl6ZWRTZWFyY2gpID4gLTE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdC8qIFRoZSB1c2VyIHR5cGVkIGEgbmV3IGxldHRlciBpbiB0aGUgaW5wdXQgYm94IChvciBkZWxldGVkIGl0KSBhbmQgdGhlIHNlYXJjaFxyXG5cdFx0XHRzdWdnZXN0aW9ucyBzaG91bGQgYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkuICovXHJcblx0XHRvbkNoYW5nZSgpIHtcclxuXHRcdFx0dGhpcy5maWx0ZXJSZXN1bHRzKCk7XHJcblx0XHRcdC8vIENoZWNrIGZvciBub24tZW1wdHkgaW5wdXQgb3Igbm9uLWVtcHR5IHJlc3VsdHNcclxuXHRcdFx0aWYgKHRoaXMuc2VhcmNoLnRyaW0oKSAhPT0gJycgfHwgdGhpcy5yZXN1bHRzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR0aGlzLmlzT3BlbiA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcblx0XHRcdFx0dGhpcy5pc09wZW4gPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIENhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvciB0YXBzIG91dHNpZGUgdGhlIGNvbXBvbmVudC4gKi9cclxuXHRcdGhhbmRsZUNsaWNrT3V0c2lkZShldmVudCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuJGVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcclxuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuXHRcdFx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG5cdFx0XHRcdC8qIE5vdCBnb29kLCBiZWNhdXNlIGl0IHdvdWxkIGFjdCBldmVuIGFmdGVyIGEgcmlnaHQgY2hvaWNlLiBDbGlja2luZ1xyXG5cdFx0XHRcdG91dHNpZGUgdGhlIGNvbXBvbmVudCBzaG91bGQgbm90IGRlbGV0ZSBhbnl0aGluZy4gKi9cclxuXHRcdFx0XHQvLyB0aGlzLmNsZWFyVHh0KCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKiBLZXlib2FyZCBzdXBwb3J0LCBmaXJlZCB3aGVuIHRoZSB1c2UgdXNlcyBhcnJvdyBrZXlzIHRvIG5hdmlnYXRlIFxyXG5cdFx0dGhyb3VnaCB0aGUgbGlzdC4gVGhpcyBvbmUgYWRkcmVzc2VzIHRoZSBhcnJvdyBkb3duIGtleS4gKi9cclxuXHRcdG9uQXJyb3dEb3duKCkge1xyXG5cdFx0XHR0aGlzLmNsZWFySG92ZXJTZWxlY3Rpb24oKTtcclxuXHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEluZGV4Kys7XHJcblx0XHRcdFx0dGhpcy5hZGRIb3ZlclNlbGVjdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMuY2FsY3VsYXRlU2Nyb2xsUG9zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHQvKiBBZGRyZXNzZXMgdGhlIGFycm93IHVwIGtleSAqL1xyXG5cdFx0b25BcnJvd1VwKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3RlZEluZGV4ID4gMCkge1xyXG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJbmRleC0tO1xyXG5cdFx0XHRcdHRoaXMuY2FsY3VsYXRlU2Nyb2xsUG9zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIFdoZW4gRW50ZXIgaXMgcHJlc3NlZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGdldHMgY2hvb3NlZC4gKi9cclxuXHRcdG9uRW50ZXIoKSB7XHJcblx0XHRcdHRoaXMuc2VhcmNoID0gdGhpcy5yZXN1bHRzW3RoaXMuc2VsZWN0ZWRJbmRleF07XHJcblx0XHRcdHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG5cdFx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdC8qIFNldHMgdGhlIHNlYXJjaCBpbnB1dCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnRseSBoaWdobGlnaHRlZCBpdGVtLCB0aGVuIGNsb3NlIFxyXG5cdFx0dGhlIHN1Z2dlc3Rpb25zIGJ5IHNldHRpbmcgaXNPcGVuIHRvIGZhbHNlLiovXHJcblx0XHRzZWxlY3RJdGVtKCkge1xyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHRoaXMuc2VhcmNoID0gdGhpcy5yZXN1bHRzW3RoaXMuc2VsZWN0ZWRJbmRleF07XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcblx0XHRcdFx0Ly8gRm9jdXMgb24gdGhlIG5leHQgaW5wdXQgZWxlbWVudFxyXG5cdFx0XHRcdHRoaXMuJG5leHRUaWNrKCgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5leHRJbnB1dCA9IHRoaXMuJHJlZnMubmV4dElucHV0RWxlbWVudDtcclxuXHRcdFx0XHRcdGlmKG5leHRJbnB1dCAmJiBuZXh0SW5wdXQuZm9jdXMpe1xyXG5cdFx0XHRcdFx0XHRuZXh0SW5wdXQuZm9jdXMoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qIFRoaXMgZnVuY3Rpb24gYW5kIHRoZSBuZXh0IG9uZSBzZWVtIHRvIGJlIG5lY2Vzc2FyeSB3aGVuIHRoZSB1c2VyIGJlZ2lucyB0byB1c2VcclxuXHRcdHRoZSBrZXlib2FyZCBhZnRlciB0aGUgdXNlciBwcmV2aW91c2x5IHVzZWQgdGhlIG1vdXNlLiBOb3Qgc3VyZSBpZiB0aGVzZSBtZXRob2RzXHJcblx0XHRhcmUgcmVhbGx5IG5lZWRlZC4gQ29tbWVudHMgYXJlIGFwcHJlY2llZC4qL1xyXG5cdFx0Y2xlYXJIb3ZlclNlbGVjdGlvbigpIHtcclxuXHRcdFx0dGhpcy4kcmVmcy5yZXN1bHRzTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCcuYXV0b2NvbXBsZXRlLXJlc3VsdCcpLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0aWYgKGluZGV4ICE9PSB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcclxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkSG92ZXJTZWxlY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuJHJlZnMucmVzdWx0c0xpc3QucXVlcnlTZWxlY3RvckFsbCgnLmF1dG9jb21wbGV0ZS1yZXN1bHQnKS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4KSB7XHJcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qIEtlZXBzIHRoZSBzZWxlY3Rpb24gb2YgdGhlIGl0ZW0gYWx3YXlzIHZlcnRpY2FsbHkgY2VudGVyZWQuICovXHJcblx0XHRjYWxjdWxhdGVTY3JvbGxQb3NpdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMucmVzdWx0c0xpc3QpO1xyXG5cdFx0XHRjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5mb250U2l6ZSk7XHJcblx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgbGluZSB3YXMgY29tbWVudGVkIGJlY2F1c2UgaXQgZG9lc24ndCB3b3JrXHJcblx0XHRcdC8vY29uc3QgbGluZVNwYWNpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUubGluZUhlaWdodCkgfHwgMS41O1xyXG5cdFx0XHRjb25zdCBsaW5lU3BhY2luZyA9IDEuNTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhjb21wdXRlZFN0eWxlLmxpbmVIZWlnaHQpO1xyXG5cdFx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLiRyZWZzLnJlc3VsdHNMaXN0O1xyXG5cdFx0XHRjb25zdCBzY3JvbGxQb3NpdGlvbiA9ICh0aGlzLnNlbGVjdGVkSW5kZXggLSAzKSAqIGxpbmVTcGFjaW5nICogZm9udFNpemU7XHJcblx0XHRcdGNvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbjtcclxuXHRcdH0sXHJcblx0XHRcclxuXHR9LFxyXG59O1xyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4uYXV0b2NvbXBsZXRlIHtcclxuXHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG59XHJcblxyXG4vKiBUaGlzIHN0eWxlIGFwcGxpZXMgdG8gdGhlIGVudGlyZSBsaXN0ICovXHJcbi5hdXRvY29tcGxldGUtcmVzdWx0cy1vbGQge1xyXG5cdGxpc3Qtc3R5bGU6IG5vbmU7XHJcblx0dGV4dC1hbGlnbjogbGVmdDtcclxuXHRwYWRkaW5nOiAwO1xyXG5cdHdpZHRoOiAzMDBweDtcclxuXHRtYXgtaGVpZ2h0OiAyMDBweDtcclxuXHRvdmVyZmxvdy15OiBzY3JvbGw7XHJcblx0LyogT24gb3ZlcmZsb3csIHdpbGwgYWRkIGEgdmVydGljYWwgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgKi9cclxuXHRvdmVyZmxvdy14OiBhdXRvO1xyXG5cdC8qIE9uIG92ZXJmbG93LCB3aWxsIGFkZCBhIGhvcml6b250YWwgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgKi9cclxuXHRib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xyXG5cdC8qIEEgbmljZSBib3JkZXIgYXJvdW5kIHRoZSBzdWdnZXN0aW9uIGxpc3QgKi9cclxuXHRtYXJnaW46IDA7XHJcblx0Ym9yZGVyLXJhZGl1czogNXB4O1xyXG59XHJcblxyXG4vKiBUaGUgbmV3IHZlcnNpb24gaXMgbW9yZSBzdWl0YWJsZSBmb3IgNy13b3JkcyB2ZXJ0aWNhbCBhbGlnbm1lbnQgKi9cclxuLmF1dG9jb21wbGV0ZS1yZXN1bHRzIHtcclxuICBsaXN0LXN0eWxlOiBub25lO1xyXG4gIHRleHQtYWxpZ246IGxlZnQ7XHJcbiAgcGFkZGluZzogMDtcclxuICB3aWR0aDogMTAwJTsgLyogVXNlIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBjb250YWluZXIgKi9cclxuICBtYXgtaGVpZ2h0OiAxMC41cmVtOyAvKiBTZXQgbWF4IGhlaWdodCB0byBhY2NvbW1vZGF0ZSA3IGl0ZW1zICovXHJcbiAgbGluZS1oZWlnaHQ6MS41cmVtO1xyXG4gIG92ZXJmbG93LXk6IGF1dG87XHJcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcclxuICBtYXJnaW46IDA7XHJcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gIGRpc3BsYXk6IGJsb2NrO1xyXG4gIGZvbnQtc2l6ZToxcmVtO1xyXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xyXG59XHJcblxyXG4vKiBUaGlzIHN0eWxlIGFwcGxpZXMgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0ICovXHJcbi5hdXRvY29tcGxldGUtcmVzdWx0IHtcclxuXHQvKnBhZGRpbmc6IDRweCAycHg7Ki9cclxuXHQvKmZvbnQtZmFtaWx5OlZlcmRhbmEsIHNhbnMtc2VyaWY7Ki9cclxuXHRwYWRkaW5nOiAuNXJlbSwwO1xyXG5cdGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuLyogV2hlbiB0aGUgbW91c2UgaG92ZXJzIGFuZCBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBsaXN0LCBlYWNoIGl0ZW0gd2lsbCBiZSBoaWdobGlnaHRlZFxyXG5cdHdpdGggYSBuaWNlIGdyZWVuIGNvbG9yLiovXHJcbi5pcy1hY3RpdmV7XHJcblx0YmFja2dyb3VuZC1jb2xvcjogIzRBQUU5ODtcclxuXHRjb2xvcjogd2hpdGU7XHJcblx0d2lkdGg6MTAwJTtcclxufVxyXG5cclxuXHJcbi5uZXh0ZWxlIHtcclxuXHR3aWR0aDogYXV0bztcclxuXHRtYXJnaW4tdG9wOi4ycmVtO1xyXG5cdHBhZGRpbmc6IDA7XHJcblx0Ym94LXNpemluZzogY29udGVudC1ib3g7XHJcblx0LyogVG8gcHJldmVudCB0aGUgaW5wdXQgZnJvbSBncm93aW5nIHdoZW4gcGFkZGluZyBpcyBhZGRlZCAqL1xyXG59XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-plugin-vuetify/dist/scriptLoader.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/SearchAutocomplete.vue?vue&type=template&id=529fd040\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ !function() {
/******/ 	__webpack_require__.h = function() { return "6c0717bd42d61050"; }
/******/ }();
/******/ 
/******/ }
);